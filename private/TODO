To do
=====

- after Racket 5.1.1 release:
  - set required-core-version to 5.1.1
  - drop private/generic/check-access.rkt
  - split private/generic/socket.rkt into separate package
  - use ryanc/macros:2/lazy-require in main.rkt
  - use ryanc/macros:2/relation in message modules

----

Testing

- run ODBC tests on Mac
- run ODBC DB2, Oracle tests on win32; also test SQL Server ?

- test connection-generators

- test kill-safe-connection by creating dummy connection object:
  - query method acquires lock, sleeps, releases lock, returns
    maybe bumps external semaphore before sleeping
    kill calling thread while sleeping to test kill-safe proxy

----

Types

- type annotations
  - two modes: mandatory and opportunistic
  - on result fields (eg sqlite, convert to date)
  - on parameters ???
  - per query or per connection? (or both?)
  - either only well-known conversions, or must apply outside of lock

- postgresql record type: docs, send
- postgresql domain types, table record types, etc

- util/postgresql: add inet types
- util/geometry: add WKT functions

- add support for ODBC intervals (no point w/o driver to test with)

----

- sqlite: allow configurable behavior on SQLITE_BUSY
  eg retry n times, retry forever, retry w/ timeout, fail
  (is db locked only for write or for whole transaction?)

- doc: enumerate errors
- document exn:fail:sql, when used, when not used, links to SQLSTATE docs?

- disconnect should always work, even on thread-damaged connections
  - but might need version with timeout and/or rudely? flag, because
    I can't think of a way to solve the lock problem that doesn't involve aux thread

- More ODBC information
  SQLGetInfo:
  - SQL_CONVERT_<datatype> - use to refine supported types (?)
  - SQL_CURSOR_{COMMIT,ROLLBACK}_BEHAVIOR - check that commit/rollback doesn't delete pstmts!
  - SQL_DATABASE_NAME (see also SQLGetConnectAttr, SQL_ATTR_CURRENT_CATALOG)
  - SQL_DBMS_NAME, SQL_DBMS_VER
  - SQL_DEFAULT_TXN_ISOLATION
  - SQL_DRIVER_NAME
  - SQL_MAX_{CATALOG,COLUMN,IDENTIFIER,SCHEMA_NAME,TABLE_NAME}_NAME (min 128)
  - SQL_SERVER_NAME
  - SQL_TXN_CAPABLE, SQL_TXN_ISOLATION_OPTION
  - SQL_USER_NAME
  SQLGetConnectAttr:
  - SQL_ATTR_AUTOCOMMIT (default is auto-commit on)
  - SQL_ATTR_CURRENT_CATALOG
  - SQL_ATTR_TXN_ISOLATION
  SQLGetStmtAttr:
  - SQL_ATTR_NOSCAN (for odbc escape sequences)

- finish transaction api (isolation levels, docs, tests)
  - figure out what happens if commit fails (non-serializable, for example)
    - if converts to rollback, how to detect?
  - add connect option #:rollback-invalid-transactions?
  - enough to implement connection pooling?

- Identify common ODBC errors that can't possibly rollback transaction
  - test with PostgreSQL ODBC driver using "rollback on all errors" mode
